[
  {
    "id": "1",
    "title": "Introduction to Algorithms",
    "preview": "Learn what algorithms are and why they matter. Understand Big O notation and algorithm performance.",
    "summary": "Algorithms are step-by-step instructions for solving problems. This chapter introduces the concept of algorithmic thinking and explains why choosing the right algorithm matters. You'll learn about Big O notation, which is used to describe how fast an algorithm runs and how much space it uses. Understanding algorithm performance helps you write efficient code that scales well.",
    "topics": [
      "What is an algorithm?",
      "Binary search vs simple search",
      "Big O notation basics",
      "Algorithm running time",
      "Common Big O run times"
    ],
    "algorithm": "function binarySearch(list, item) {\n  let low = 0;\n  let high = list.length - 1;\n\n  while (low <= high) {\n    const mid = Math.floor((low + high) / 2);\n    const guess = list[mid];\n\n    if (guess === item) {\n      return mid;\n    }\n    if (guess > item) {\n      high = mid - 1;\n    } else {\n      low = mid + 1;\n    }\n  }\n  return null;\n}"
  },
  {
    "id": "2",
    "title": "Selection Sort",
    "preview": "Understand how arrays and linked lists work. Learn selection sort algorithm.",
    "summary": "This chapter covers two fundamental data structures: arrays and linked lists. Arrays store elements in contiguous memory locations, making random access fast. Linked lists store elements anywhere in memory with pointers connecting them, making insertions and deletions efficient. You'll also learn selection sort, a simple sorting algorithm that repeatedly finds the minimum element.",
    "topics": [
      "How memory works",
      "Arrays and linked lists",
      "Selection sort algorithm",
      "Time complexity of operations",
      "When to use arrays vs linked lists"
    ],
    "algorithm": "function findSmallest(arr) {\n  let smallest = arr[0];\n  let smallestIndex = 0;\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] < smallest) {\n      smallest = arr[i];\n      smallestIndex = i;\n    }\n  }\n  return smallestIndex;\n}\n\nfunction selectionSort(arr) {\n  const newArr = [];\n  const length = arr.length;\n  for (let i = 0; i < length; i++) {\n    const smallest = findSmallest(arr);\n    newArr.push(arr.splice(smallest, 1)[0]);\n  }\n  return newArr;\n}"
  },
  {
    "id": "3",
    "title": "Recursion",
    "preview": "Master the art of recursion and understand how functions call themselves.",
    "summary": "Recursion is when a function calls itself. It's a powerful technique used in many algorithms. Every recursive function has two parts: the base case (when to stop) and the recursive case (when to keep going). This chapter explains the call stack, how recursion works under the hood, and common pitfalls like stack overflow. Recursion makes some problems much easier to solve.",
    "topics": [
      "What is recursion?",
      "Base case and recursive case",
      "The call stack",
      "Stack overflow",
      "Recursion vs loops"
    ],
    "algorithm": "function factorial(n) {\n  if (n === 1) {\n    return 1;\n  }\n  return n * factorial(n - 1);\n}\n\nfunction countdown(i) {\n  console.log(i);\n  if (i <= 0) {\n    return;\n  }\n  countdown(i - 1);\n}"
  },
  {
    "id": "4",
    "title": "Quicksort",
    "preview": "Learn one of the most popular sorting algorithms using divide and conquer.",
    "summary": "Quicksort is a fast sorting algorithm that uses the divide-and-conquer strategy. It works by selecting a 'pivot' element and partitioning the array around it. Elements smaller than the pivot go to the left, larger elements go to the right. Then it recursively sorts the sub-arrays. Quicksort is widely used because of its excellent average-case performance of O(n log n).",
    "topics": [
      "Divide and conquer strategy",
      "How quicksort works",
      "Partitioning",
      "Choosing a good pivot",
      "Time complexity analysis",
      "Quicksort vs merge sort"
    ],
    "algorithm": "function quicksort(arr) {\n  if (arr.length < 2) {\n    return arr;\n  }\n  \n  const pivot = arr[0];\n  const less = arr.slice(1).filter(el => el <= pivot);\n  const greater = arr.slice(1).filter(el => el > pivot);\n  \n  return [...quicksort(less), pivot, ...quicksort(greater)];\n}"
  },
  {
    "id": "5",
    "title": "Hash Tables",
    "preview": "Discover the power of hash tables for fast lookups and data organization.",
    "summary": "Hash tables (also called hash maps or dictionaries) are one of the most useful data structures. They provide incredibly fast lookups, insertions, and deletions - all in O(1) average time. Hash tables use a hash function to compute an index where values are stored. They're used everywhere: databases, caches, and countless applications. Understanding hash tables is essential for any programmer.",
    "topics": [
      "Hash functions",
      "Hash table structure",
      "Collisions and how to handle them",
      "Use cases for hash tables",
      "Performance characteristics",
      "Load factor"
    ],
    "algorithm": "class HashTable {\n  constructor(size = 53) {\n    this.keyMap = new Array(size);\n  }\n\n  _hash(key) {\n    let total = 0;\n    const PRIME = 31;\n    for (let i = 0; i < Math.min(key.length, 100); i++) {\n      const char = key[i];\n      const value = char.charCodeAt(0) - 96;\n      total = (total * PRIME + value) % this.keyMap.length;\n    }\n    return total;\n  }\n\n  set(key, value) {\n    const index = this._hash(key);\n    if (!this.keyMap[index]) {\n      this.keyMap[index] = [];\n    }\n    this.keyMap[index].push([key, value]);\n  }\n\n  get(key) {\n    const index = this._hash(key);\n    if (this.keyMap[index]) {\n      for (let i = 0; i < this.keyMap[index].length; i++) {\n        if (this.keyMap[index][i][0] === key) {\n          return this.keyMap[index][i][1];\n        }\n      }\n    }\n    return undefined;\n  }\n}"
  },
  {
    "id": "6",
    "title": "Breadth-First Search",
    "preview": "Learn graph algorithms and how to find the shortest path using BFS.",
    "summary": "Graphs are a way to model connections between things. This chapter introduces graph theory and breadth-first search (BFS), an algorithm for searching graphs. BFS explores all neighbors at the current depth before moving to nodes at the next depth level. It's perfect for finding the shortest path in an unweighted graph. You'll learn about directed vs undirected graphs, and how to implement BFS using a queue.",
    "topics": [
      "What are graphs?",
      "Directed vs undirected graphs",
      "Breadth-first search algorithm",
      "Queues",
      "Finding shortest path",
      "Topological sort"
    ],
    "algorithm": "function breadthFirstSearch(graph, start, target) {\n  const queue = [start];\n  const visited = new Set();\n  \n  while (queue.length > 0) {\n    const node = queue.shift();\n    \n    if (node === target) {\n      return true;\n    }\n    \n    if (!visited.has(node)) {\n      visited.add(node);\n      const neighbors = graph[node] || [];\n      queue.push(...neighbors);\n    }\n  }\n  \n  return false;\n}"
  },
  {
    "id": "7",
    "title": "Dijkstra's Algorithm",
    "preview": "Find the fastest path in weighted graphs using Dijkstra's algorithm.",
    "summary": "Dijkstra's algorithm finds the shortest path in a weighted graph. Unlike BFS which works with unweighted graphs, Dijkstra's handles graphs where edges have different costs. It's used in GPS systems, network routing, and many other applications. The algorithm maintains a table of the shortest known distance to each node and updates it as it explores the graph. You'll also learn about negative weights and why Dijkstra's doesn't work with them.",
    "topics": [
      "Weighted graphs",
      "Dijkstra's algorithm steps",
      "Priority queues",
      "Negative weight edges",
      "Real-world applications",
      "Bellman-Ford algorithm"
    ],
    "algorithm": "function dijkstra(graph, start, end) {\n  const distances = {};\n  const visited = new Set();\n  const previous = {};\n  const queue = [];\n  \n  for (let node in graph) {\n    distances[node] = Infinity;\n  }\n  distances[start] = 0;\n  queue.push({ node: start, distance: 0 });\n  \n  while (queue.length > 0) {\n    queue.sort((a, b) => a.distance - b.distance);\n    const { node } = queue.shift();\n    \n    if (node === end) break;\n    if (visited.has(node)) continue;\n    \n    visited.add(node);\n    \n    for (let neighbor in graph[node]) {\n      const distance = distances[node] + graph[node][neighbor];\n      if (distance < distances[neighbor]) {\n        distances[neighbor] = distance;\n        previous[neighbor] = node;\n        queue.push({ node: neighbor, distance });\n      }\n    }\n  }\n  \n  return distances[end];\n}"
  },
  {
    "id": "8",
    "title": "Greedy Algorithms",
    "preview": "Learn when to use greedy algorithms and understand their trade-offs.",
    "summary": "Greedy algorithms make the locally optimal choice at each step, hoping to find a global optimum. They're simple and fast but don't always give the best solution. This chapter covers the set-covering problem and explains when greedy algorithms work well. You'll learn about NP-complete problems - problems for which no fast solution is known. Greedy algorithms often provide good approximations for these hard problems.",
    "topics": [
      "What are greedy algorithms?",
      "The set-covering problem",
      "Approximation algorithms",
      "NP-complete problems",
      "When to use greedy algorithms",
      "Classroom scheduling example"
    ],
    "algorithm": "function setCover(universe, subsets) {\n  const covered = new Set();\n  const selectedSets = [];\n  \n  while (covered.size < universe.size) {\n    let bestSet = null;\n    let bestCoverage = new Set();\n    \n    for (let [name, subset] of Object.entries(subsets)) {\n      const coverage = new Set([...subset].filter(x => !covered.has(x)));\n      if (coverage.size > bestCoverage.size) {\n        bestSet = name;\n        bestCoverage = coverage;\n      }\n    }\n    \n    if (bestSet) {\n      selectedSets.push(bestSet);\n      bestCoverage.forEach(item => covered.add(item));\n    }\n  }\n  \n  return selectedSets;\n}"
  },
  {
    "id": "9",
    "title": "Dynamic Programming",
    "preview": "Solve complex problems by breaking them into simpler subproblems.",
    "summary": "Dynamic programming is a technique for solving complex problems by breaking them down into simpler subproblems. It's useful when subproblems overlap - you solve each subproblem once and store the result. This chapter uses the knapsack problem to illustrate dynamic programming. You'll learn to build a grid to solve problems systematically. Dynamic programming is powerful but can be tricky to master.",
    "topics": [
      "What is dynamic programming?",
      "The knapsack problem",
      "Building a grid",
      "Memoization",
      "Longest common substring",
      "When to use dynamic programming"
    ],
    "algorithm": "function knapsack(items, capacity) {\n  const n = items.length;\n  const dp = Array(n + 1).fill(null).map(() => Array(capacity + 1).fill(0));\n  \n  for (let i = 1; i <= n; i++) {\n    const { weight, value } = items[i - 1];\n    for (let w = 0; w <= capacity; w++) {\n      if (weight <= w) {\n        dp[i][w] = Math.max(\n          dp[i - 1][w],\n          dp[i - 1][w - weight] + value\n        );\n      } else {\n        dp[i][w] = dp[i - 1][w];\n      }\n    }\n  }\n  \n  return dp[n][capacity];\n}"
  },
  {
    "id": "10",
    "title": "K-Nearest Neighbors",
    "preview": "Build recommendation systems and classifiers using machine learning.",
    "summary": "K-nearest neighbors (KNN) is a simple machine learning algorithm used for classification and regression. It works by finding the k closest data points to a new point and using them to make predictions. This chapter introduces machine learning concepts like feature extraction, regression, and classification. You'll learn how to build recommendation systems and spam filters. KNN is a great introduction to machine learning.",
    "topics": [
      "Introduction to machine learning",
      "KNN algorithm",
      "Feature extraction",
      "Regression vs classification",
      "Cosine similarity",
      "Building recommendation systems",
      "OCR and spam filters"
    ],
    "algorithm": "function euclideanDistance(point1, point2) {\n  return Math.sqrt(\n    point1.reduce((sum, val, i) => \n      sum + Math.pow(val - point2[i], 2), 0\n    )\n  );\n}\n\nfunction knn(data, query, k) {\n  const distances = data.map(point => ({\n    point,\n    distance: euclideanDistance(point.features, query)\n  }));\n  \n  distances.sort((a, b) => a.distance - b.distance);\n  const neighbors = distances.slice(0, k);\n  \n  const votes = {};\n  neighbors.forEach(({ point }) => {\n    votes[point.label] = (votes[point.label] || 0) + 1;\n  });\n  \n  return Object.keys(votes).reduce((a, b) => \n    votes[a] > votes[b] ? a : b\n  );\n}"
  },
  {
    "id": "11",
    "title": "Where to Go Next",
    "preview": "Explore advanced topics and continue your algorithm learning journey.",
    "summary": "This final chapter points you toward more advanced topics in computer science and algorithms. You'll get an overview of trees (binary search trees, B-trees, heaps), inverted indexes for search engines, the Fourier transform for signal processing, parallel algorithms, and MapReduce for distributed computing. There's also coverage of Bloom filters, HyperLogLog, SHA algorithms, and more. This chapter shows you the vast landscape of algorithms waiting to be explored.",
    "topics": [
      "Trees (BST, B-trees, heaps)",
      "Inverted indexes",
      "Fourier transform",
      "Parallel algorithms",
      "MapReduce",
      "Bloom filters and HyperLogLog",
      "SHA algorithms",
      "Locality-sensitive hashing",
      "Diffie-Hellman key exchange",
      "Linear programming"
    ],
    "algorithm": "class BinarySearchTree {\n  constructor() {\n    this.root = null;\n  }\n\n  insert(value) {\n    const newNode = { value, left: null, right: null };\n    \n    if (!this.root) {\n      this.root = newNode;\n      return;\n    }\n    \n    let current = this.root;\n    while (true) {\n      if (value < current.value) {\n        if (!current.left) {\n          current.left = newNode;\n          return;\n        }\n        current = current.left;\n      } else {\n        if (!current.right) {\n          current.right = newNode;\n          return;\n        }\n        current = current.right;\n      }\n    }\n  }\n\n  search(value) {\n    let current = this.root;\n    while (current) {\n      if (value === current.value) return true;\n      current = value < current.value ? current.left : current.right;\n    }\n    return false;\n  }\n}"
  }
]
